-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Comprehensive Google Services SDK.
--   
--   This client library contains request and response logic to communicate
--   with Google Services compatible APIs using the types supplied by the
--   various <tt>gogol-*</tt> service libraries. See the <a>Google</a>
--   category on Hackage for supported services.
--   
--   To get started, import the desired <tt>gogol-*</tt> library (such as
--   <a>Network.Google.Gmail</a>) and <tt>Network.Google</tt> from this
--   package.
--   
--   <i>Warning:</i> This is an experimental prototype/preview release
--   which is still under exploratory development and not intended for
--   public use, caveat emptor!
--   
--   GHC 7.10.2 and higher is officially supported.
@package gogol
@version 0.3.0


-- | Google Compute Engine defines a set of default metadata entries that
--   provide information about your instance or project.
--   
--   This module contains functions for retrieving various Compute metadata
--   from an instance's local metadata endpoint using <a>MonadIO</a>, prior
--   to initialisation of the environment used by the <a>Network.Google</a>
--   monad.
module Network.Google.Compute.Metadata

-- | The <tt>NO_GCE_CHECK</tt> environment variable.
checkGCEVar :: String

-- | Detect if the underlying host is running on GCE.
--   
--   The environment variable <tt>NO_GCE_CHECK</tt> can be set to
--   <tt>1</tt>, <tt>true</tt>, <tt>yes</tt>, or <tt>on</tt> to skip this
--   check and always return <tt>False</tt>.
isGCE :: MonadIO m => Manager -> m Bool

-- | A directory of custom metadata values that have been set for this
--   project.
getProjectAttribute :: MonadIO m => Text -> Manager -> m (Maybe ByteString)

-- | SSH keys that can connect to instances in the project. SSH keys for
--   Compute Engine use a specialized format where the keys are prepended
--   with a username, like so: <tt>user1:ssh-rsa my-public-ssh-key
--   user1</tt>host.com@
getSSHKeys :: MonadIO m => Manager -> m [Text]

-- | The numeric project ID of the instance, which is not the same as the
--   project name visible in the Google Developers Console. This value is
--   different from the project-id metadata entry value. The project-id
--   value is required for all requests to the Compute Engine service.
getNumericProjectId :: MonadIO m => Manager -> m Text

-- | The project ID.
getProjectId :: MonadIO m => Manager -> m Text

-- | A directory of custom metadata values passed to the instance during
--   startup or shutdown.
getInstanceAttribute :: MonadIO m => Text -> Manager -> m (Maybe ByteString)

-- | The free-text description of an instance, assigned using the
--   <tt>--description</tt> flag, or set in the API.
getDescription :: MonadIO m => Manager -> m Text

-- | The host name of the instance.
getHostname :: MonadIO m => Manager -> m Text

-- | The ID of the instance. This is a unique, numerical ID that is
--   generated by Google Compute Engine. This is useful for identifying
--   instances if you do not want to use instance names.
getInstanceId :: MonadIO m => Manager -> m Text

-- | The fully-qualified machine type name of the instance's host machine.
getMachineType :: MonadIO m => Manager -> m Text

-- | Any tags associated with the instance.
getTags :: MonadIO m => Manager -> m [Text]

-- | The instance's zone.
getZone :: MonadIO m => Manager -> m Text

-- | The <tt>Metadata-Flavor</tt> header.
metadataFlavorHeader :: HeaderName

-- | The desired metadata flavor.
metadataFlavorDesired :: ByteString

-- | A default <tt>http-client</tt> <a>Request</a> with the host, port, and
--   headers set appropriately for <tt>metadata.google.internal</tt> use.
metadataRequest :: Request
getMetadata :: MonadIO m => ByteString -> [Int] -> Manager -> m (Response ByteString)


-- | Helpers for specifying and using <tt>Scope</tt>s with
--   <a>Network.Google</a>.
module Network.Google.Auth.Scope

-- | Annotate credentials with the specified scopes. This exists to allow
--   users to choose between using <tt>newEnv</tt> with a <a>Proxy</a>
--   constructed by <a>!</a>, or explicitly specifying scopes via a type
--   annotation.
--   
--   <i>See:</i> <a>!</a>, <tt>envScopes</tt>, and the scopes available for
--   each service.
allow :: proxy s -> k s -> k s

-- | Annotate credentials with no scope authorization.
forbid :: k '[] -> k '[]

-- | Append two sets of scopes.
--   
--   <i>See:</i> <a>allow</a>.
(!) :: proxy xs -> proxy ys -> Proxy (Nub (xs ++ ys))

-- | Determine if _any_ of the scopes a request requires is listed in the
--   scopes the credentials supports.
--   
--   For error message/presentation purposes, this wraps the result of the
--   <a>HasScope</a> membership check to show both lists of scopes before
--   reduction.

-- | Check if any of actual supplied scopes <tt>s</tt> exist in the
--   required set <tt>a</tt>. If the required set <tt>a</tt> is empty, then
--   succeed.

-- | Membership predicate.

-- | Append two lists.

-- | Remove duplicates from a list.

-- | Remove a specific element from a list.
class AllowScopes a

-- | Obtain a list of supported <a>OAuthScope</a> values from a proxy.
allowScopes :: AllowScopes a => proxy a -> [OAuthScope]

-- | Concatenate a list of scopes using spaces.
concatScopes :: [OAuthScope] -> Text

-- | Encode a list of scopes suitable for embedding in a query string.
queryEncodeScopes :: [OAuthScope] -> ByteString
instance Network.Google.Auth.Scope.AllowScopes '[]
instance (GHC.TypeLits.KnownSymbol x, Network.Google.Auth.Scope.AllowScopes xs) => Network.Google.Auth.Scope.AllowScopes (x : xs)
instance Network.Google.Auth.Scope.AllowScopes s => Network.Google.Auth.Scope.AllowScopes (Network.Google.Internal.Auth.Credentials s)


-- | Application Default Credentials are suited for cases when access to a
--   Google service needs to have the same identity and authorization level
--   for the application independent of the user. This is Google's the
--   recommended approach to authorize calls to Google Cloud APIs,
--   particularly when you're building an application that is deployed to
--   Google App Engine or Google Compute Engine virtual machines.
--   
--   <i>See:</i> <a>Application Default Documentation</a>.
module Network.Google.Auth.ApplicationDefault

-- | The environment variable name which is used to specify the directory
--   containing the <tt>application_default_credentials.json</tt> generated
--   by <tt>gcloud init</tt>.
cloudSDKConfigDir :: String

-- | Return the filepath to the Cloud SDK well known file location such as
--   <tt>~/.config/gcloud/application_default_credentials.json</tt>.
cloudSDKConfigPath :: MonadIO m => m FilePath

-- | The environment variable pointing the file with local Application
--   Default Credentials.
defaultCredentialsFile :: String

-- | Lookup the <tt>GOOGLE_APPLICATION_CREDENTIALS</tt> environment
--   variable for the default application credentials filepath.
defaultCredentialsPath :: MonadIO m => m (Maybe FilePath)

-- | Performs credentials discovery in the following order:
--   
--   <ol>
--   <li>Read the default credentials from a file specified by the
--   environment variable <tt>GOOGLE_APPLICATION_CREDENTIALS</tt> if it
--   exists.</li>
--   <li>Read the platform equivalent of
--   <tt>~/.config/gcloud/application_default_credentials.json</tt> if it
--   exists. The <tt>~/.config</tt> component of the path can be overriden
--   by the environment variable <tt>CLOUDSDK_CONFIG</tt> if it
--   exists.</li>
--   <li>Retrieve the default service account application credentials if
--   running on GCE. The environment variable <tt>NO_GCE_CHECK</tt> can be
--   used to skip this check if set to a truthy value such as <tt>1</tt> or
--   <tt>true</tt>.</li>
--   </ol>
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate OAuth2
--   scopes, otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
--   
--   <i>See:</i> <a>Application Default Credentials</a>
getApplicationDefault :: (MonadIO m, MonadCatch m) => Manager -> m (Credentials s)

-- | Attempt to load either a <tt>service_account</tt> or
--   <tt>authorized_user</tt> formatted file to obtain the credentials
--   neccessary to perform a token refresh.
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate scopes,
--   otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
--   
--   <i>See:</i> <a>cloudSDKConfigPath</a>, <a>defaultCredentialsPath</a>.
fromWellKnownPath :: (MonadIO m, MonadCatch m) => m (Credentials s)

-- | Attempt to load either a <tt>service_account</tt> or
--   <tt>authorized_user</tt> formatted file to obtain the credentials
--   neccessary to perform a token refresh from the specified file.
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate scopes,
--   otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
fromFilePath :: (MonadIO m, MonadCatch m) => FilePath -> m (Credentials s)

-- | Save <a>AuthorizedUser</a> <i>See:</i> <a>cloudSDKConfigPath</a>,
--   <a>defaultCredentialsPath</a>.
saveAuthorizedUserToWellKnownPath :: (MonadIO m, MonadCatch m) => Bool -> AuthorizedUser -> m ()

-- | Save <a>AuthorizedUser</a>
saveAuthorizedUser :: (MonadIO m, MonadCatch m) => FilePath -> Bool -> AuthorizedUser -> m ()

-- | Attempt to parse either a <tt>service_account</tt> or
--   <tt>authorized_user</tt> formatted JSON value to obtain credentials.
fromJSONCredentials :: ByteString -> Either String (Credentials s)
getConfigDirectory :: MonadIO m => m FilePath


-- | Credentials for Server to Server communication, such as between a
--   deployed web application and a Google service.
--   
--   Typically, an application uses a service account when the application
--   uses Google services to work with its own data rather than a specific
--   user's data.
--   
--   <i>See:</i> <a>Service Account Documentation</a>.
module Network.Google.Auth.ServiceAccount

-- | The maximum lifetime of a <tt>service_account</tt> token which is 1
--   hour, in seconds.
maxTokenLifetime :: Seconds

-- | Obtain an <a>OAuthToken</a> from the local instace metadata using the
--   specific <a>ServiceId</a>.
--   
--   For example:
--   <tt>http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token</tt>
--   will be retrieved if the given <a>ServiceId</a> is <tt>"default"</tt>.
metadataToken :: (MonadIO m, MonadCatch m) => ServiceId -> Logger -> Manager -> m (OAuthToken s)

-- | Use the <a>AuthorizedUser</a> to obtain a new <a>OAuthToken</a>. If
--   the supplied <a>RefreshToken</a> is <a>Nothing</a>, the original
--   <a>RefreshToken</a> from the user will be used.
authorizedUserToken :: (MonadIO m, MonadCatch m) => AuthorizedUser -> Maybe RefreshToken -> Logger -> Manager -> m (OAuthToken s)

-- | Obtain an <a>OAuthToken</a> from
--   <tt><a>https://accounts.google.com/o/oauth2/v2/auth</a></tt> by
--   signing and sending a JSON Web Token (JWT) using the supplied
--   <a>ServiceAccount</a>.
serviceAccountToken :: (MonadIO m, MonadCatch m, AllowScopes s) => ServiceAccount -> proxy s -> Logger -> Manager -> m (OAuthToken s)

-- | Encode the supplied <a>ServiceAccount</a>s key id, email, and scopes
--   using the private key in the JSON Web Token (JWT) format.
encodeBearerJWT :: (MonadIO m, MonadThrow m, AllowScopes s) => ServiceAccount -> proxy s -> m ByteString


-- | Credentials for applications that are installed on devices such as
--   computers, cell phones, or a tablet. Installed apps are distributed to
--   individual machines, and it is assumed that these apps securely store
--   secrets.
--   
--   These apps might access a Google service while the user is present at
--   the application, or when the application is running in the background.
--   
--   <i>See:</i> <a>Installed Application Documentation</a>.
module Network.Google.Auth.InstalledApplication

-- | Create new Installed Application credentials.
--   
--   Since it is intended that the user opens the URL generated by
--   <a>formURL</a> in a browser and the resulting <a>OAuthCode</a> is then
--   received out-of-band, you must ensure that the scopes passed to
--   <a>formURL</a> and the type of <a>OAuthCode</a> correctly match,
--   otherwise an authorization error will occur.
--   
--   For example, doing this via <a>getLine</a> and copy-paste:
--   
--   <pre>
--   {-# LANGUAGE ScopedTypeVariables #-}
--   </pre>
--   
--   <pre>
--   import Data.Proxy     (Proxy (..))
--   import Data.Text      as T
--   import Data.Text.IO   as T
--   import System.Exit    (exitFailure)
--   import System.Info    (os)
--   import System.Process (rawSystem)
--   </pre>
--   
--   <pre>
--   redirectPrompt :: AllowScopes (s :: [Symbol]) =&gt; OAuthClient -&gt; proxy s -&gt; IO (OAuthCode s)
--   redirectPrompt c p = do
--     let url = formURL c p
--     T.putStrLn $ "Opening URL " `T.append` url
--     _ &lt;- case os of
--       "darwin" -&gt; rawSystem "open"     [unpack url]
--       "linux"  -&gt; rawSystem "xdg-open" [unpack url]
--       _        -&gt; T.putStrLn "Unsupported OS" &gt;&gt; exitFailure
--     T.putStrLn "Please input the authorisation code: "
--     OAuthCode &lt;$&gt; T.getLine
--   </pre>
--   
--   This ensures the scopes passed to <a>formURL</a> and the type of
--   <a>OAuthCode</a> <tt>s</tt> are correct.
installedApplication :: OAuthClient -> OAuthCode s -> Credentials s
data AccessType
Online :: AccessType
Offline :: AccessType

-- | The redirection URI used in <a>formURL</a>:
--   <tt>urn:ietf:wg:oauth:2.0:oob</tt>.
redirectURI :: Text

-- | Given an <a>OAuthClient</a> and a list of scopes to authorize,
--   construct a URL that can be used to obtain the <a>OAuthCode</a>.
--   
--   <i>See:</i> <a>Forming the URL</a>.
formURL :: AllowScopes (s :: [Symbol]) => OAuthClient -> proxy s -> Text

-- | <a>formURL</a> for <a>AccessType</a>
--   
--   <i>See:</i> <tt>formUrl</tt>.
formAccessTypeURL :: AllowScopes (s :: [Symbol]) => OAuthClient -> AccessType -> proxy s -> Text

-- | Form a URL using <a>OAuthScope</a> values.
--   
--   <i>See:</i> <a>formURL</a>.
formURLWith :: OAuthClient -> [OAuthScope] -> Text

-- | <a>formURLWith</a> for <a>AccessType</a>
--   
--   <i>See:</i> <a>formURLWith</a>.
formAccessTypeURLWith :: OAuthClient -> AccessType -> [OAuthScope] -> Text

-- | Exchange <a>OAuthClient</a> details and the received <a>OAuthCode</a>
--   for a new <a>OAuthToken</a>.
--   
--   <i>See:</i> <a>Exchanging the code</a>.
exchangeCode :: (MonadIO m, MonadCatch m) => OAuthClient -> (OAuthCode s) -> Logger -> Manager -> m (OAuthToken s)

-- | Perform a refresh to obtain a valid <a>OAuthToken</a> with a new
--   expiry time.
--   
--   <i>See:</i> <a>Refreshing tokens</a>.
refreshToken :: (MonadIO m, MonadCatch m) => OAuthClient -> (OAuthToken s) -> Logger -> Manager -> m (OAuthToken s)
instance GHC.Classes.Eq Network.Google.Auth.InstalledApplication.AccessType
instance GHC.Show.Show Network.Google.Auth.InstalledApplication.AccessType


-- | Explicitly specify your Google credentials, or retrieve them from the
--   underlying OS.
module Network.Google.Auth

-- | The supported credential mechanisms.
data Credentials (s :: [Symbol])

-- | Obtain and refresh access tokens from the underlying GCE host metadata
--   at <tt>http://169.254.169.254</tt>.
FromMetadata :: !ServiceId -> Credentials

-- | Obtain and refresh access tokens using the specified client secret and
--   authorization code obtained from.
--   
--   See the <a>OAuth2 Installed Application</a> documentation for more
--   information.
FromClient :: !OAuthClient -> !(OAuthCode s) -> Credentials

-- | Use the specified <tt>service_account</tt> and scopes to sign and
--   request an access token. The <a>ServiceAccount</a> will also be used
--   for subsequent token refreshes.
--   
--   A <a>ServiceAccount</a> is typically generated through the Google
--   Developer Console.
FromAccount :: !ServiceAccount -> Credentials

-- | Use the specified <tt>authorized_user</tt> to obtain and refresh
--   access tokens.
--   
--   An <a>AuthorizedUser</a> is typically created by the <tt>gcloud
--   init</tt> command of the Google CloudSDK Tools.
FromUser :: !AuthorizedUser -> Credentials

-- | Performs credentials discovery in the following order:
--   
--   <ol>
--   <li>Read the default credentials from a file specified by the
--   environment variable <tt>GOOGLE_APPLICATION_CREDENTIALS</tt> if it
--   exists.</li>
--   <li>Read the platform equivalent of
--   <tt>~/.config/gcloud/application_default_credentials.json</tt> if it
--   exists. The <tt>~/.config</tt> component of the path can be overriden
--   by the environment variable <tt>CLOUDSDK_CONFIG</tt> if it
--   exists.</li>
--   <li>Retrieve the default service account application credentials if
--   running on GCE. The environment variable <tt>NO_GCE_CHECK</tt> can be
--   used to skip this check if set to a truthy value such as <tt>1</tt> or
--   <tt>true</tt>.</li>
--   </ol>
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate OAuth2
--   scopes, otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
--   
--   <i>See:</i> <a>Application Default Credentials</a>
getApplicationDefault :: (MonadIO m, MonadCatch m) => Manager -> m (Credentials s)

-- | Attempt to load either a <tt>service_account</tt> or
--   <tt>authorized_user</tt> formatted file to obtain the credentials
--   neccessary to perform a token refresh.
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate scopes,
--   otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
--   
--   <i>See:</i> <a>cloudSDKConfigPath</a>, <a>defaultCredentialsPath</a>.
fromWellKnownPath :: (MonadIO m, MonadCatch m) => m (Credentials s)

-- | Attempt to load either a <tt>service_account</tt> or
--   <tt>authorized_user</tt> formatted file to obtain the credentials
--   neccessary to perform a token refresh from the specified file.
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate scopes,
--   otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
fromFilePath :: (MonadIO m, MonadCatch m) => FilePath -> m (Credentials s)

-- | Save <a>AuthorizedUser</a> <i>See:</i> <a>cloudSDKConfigPath</a>,
--   <a>defaultCredentialsPath</a>.
saveAuthorizedUserToWellKnownPath :: (MonadIO m, MonadCatch m) => Bool -> AuthorizedUser -> m ()

-- | Save <a>AuthorizedUser</a>
saveAuthorizedUser :: (MonadIO m, MonadCatch m) => FilePath -> Bool -> AuthorizedUser -> m ()

-- | Set the user to be impersonated for a service account with domain wide
--   delegation. See
--   <a>https://developers.google.com/identity/protocols/OAuth2ServiceAccount</a>
serviceAccountUser :: forall s. (AllowScopes s) => Maybe Text -> Credentials s -> Credentials s

-- | Create new Installed Application credentials.
--   
--   Since it is intended that the user opens the URL generated by
--   <a>formURL</a> in a browser and the resulting <a>OAuthCode</a> is then
--   received out-of-band, you must ensure that the scopes passed to
--   <a>formURL</a> and the type of <a>OAuthCode</a> correctly match,
--   otherwise an authorization error will occur.
--   
--   For example, doing this via <a>getLine</a> and copy-paste:
--   
--   <pre>
--   {-# LANGUAGE ScopedTypeVariables #-}
--   </pre>
--   
--   <pre>
--   import Data.Proxy     (Proxy (..))
--   import Data.Text      as T
--   import Data.Text.IO   as T
--   import System.Exit    (exitFailure)
--   import System.Info    (os)
--   import System.Process (rawSystem)
--   </pre>
--   
--   <pre>
--   redirectPrompt :: AllowScopes (s :: [Symbol]) =&gt; OAuthClient -&gt; proxy s -&gt; IO (OAuthCode s)
--   redirectPrompt c p = do
--     let url = formURL c p
--     T.putStrLn $ "Opening URL " `T.append` url
--     _ &lt;- case os of
--       "darwin" -&gt; rawSystem "open"     [unpack url]
--       "linux"  -&gt; rawSystem "xdg-open" [unpack url]
--       _        -&gt; T.putStrLn "Unsupported OS" &gt;&gt; exitFailure
--     T.putStrLn "Please input the authorisation code: "
--     OAuthCode &lt;$&gt; T.getLine
--   </pre>
--   
--   This ensures the scopes passed to <a>formURL</a> and the type of
--   <a>OAuthCode</a> <tt>s</tt> are correct.
installedApplication :: OAuthClient -> OAuthCode s -> Credentials s

-- | Given an <a>OAuthClient</a> and a list of scopes to authorize,
--   construct a URL that can be used to obtain the <a>OAuthCode</a>.
--   
--   <i>See:</i> <a>Forming the URL</a>.
formURL :: AllowScopes (s :: [Symbol]) => OAuthClient -> proxy s -> Text

-- | Apply the (by way of possible token refresh) a bearer token to the
--   authentication header of a request.
authorize :: (MonadIO m, MonadCatch m, AllowScopes s) => Request -> Store s -> Logger -> Manager -> m Request

-- | Data store which ensures thread-safe access of credentials.
data Store (s :: [Symbol])

-- | Construct storage containing the credentials which have not yet been
--   exchanged or refreshed.
initStore :: (MonadIO m, MonadCatch m, AllowScopes s) => Credentials s -> Logger -> Manager -> m (Store s)

-- | Retrieve auth from storage
retrieveAuthFromStore :: (MonadIO m, MonadCatch m, AllowScopes s) => Store s -> m (Auth s)

-- | An <a>OAuthToken</a> that can potentially be expired, with the
--   original credentials that can be used to perform a refresh.
data Auth (s :: [Symbol])
Auth :: !(Credentials s) -> !(OAuthToken s) -> Auth
[_credentials] :: Auth -> !(Credentials s)
[_token] :: Auth -> !(OAuthToken s)

-- | <a>authToAuthorizedUser</a> converts <a>Auth</a> into an
--   <a>AuthorizedUser</a> by returning <a>Right</a> if there is a
--   <a>FromClient</a>-constructed Credentials and a refreshed token;
--   otherwise, returning <a>Left</a> with error message.
authToAuthorizedUser :: AllowScopes s => Auth s -> Either Text AuthorizedUser

-- | Perform the initial credentials exchange to obtain a valid
--   <a>OAuthToken</a> suitable for authorizing requests.
exchange :: forall m s. (MonadIO m, MonadCatch m, AllowScopes s) => Credentials s -> Logger -> Manager -> m (Auth s)

-- | Refresh an existing <a>OAuthToken</a>.
refresh :: forall m s. (MonadIO m, MonadCatch m, AllowScopes s) => Auth s -> Logger -> Manager -> m (Auth s)

-- | The <tt>NO_GCE_CHECK</tt> environment variable.
checkGCEVar :: String

-- | The environment variable name which is used to specify the directory
--   containing the <tt>application_default_credentials.json</tt> generated
--   by <tt>gcloud init</tt>.
cloudSDKConfigDir :: String

-- | The environment variable pointing the file with local Application
--   Default Credentials.
defaultCredentialsFile :: String
class AsAuthError a

-- | A general authentication error.
_AuthError :: AsAuthError a => Prism' a AuthError

-- | An error occured while communicating over HTTP with either then local
--   metadata or remote accounts.google.com endpoints.
_RetrievalError :: AsAuthError a => Prism' a HttpException

-- | The specified default credentials file could not be found.
_MissingFileError :: AsAuthError a => Prism' a FilePath

-- | An error occured parsing the default credentials file.
_InvalidFileError :: AsAuthError a => Prism' a (FilePath, Text)

-- | An error occured when attempting to refresh a token.
_TokenRefreshError :: AsAuthError a => Prism' a (Status, Text, Maybe Text)

-- | An error thrown when attempting to read<i>write AuthN</i>AuthZ
--   information.
data AuthError
RetrievalError :: HttpException -> AuthError
MissingFileError :: FilePath -> AuthError
InvalidFileError :: FilePath -> Text -> AuthError
TokenRefreshError :: Status -> Text -> (Maybe Text) -> AuthError
FileExistError :: FilePath -> AuthError

-- | A client identifier and accompanying secret used to obtain/refresh a
--   token.
data OAuthClient
OAuthClient :: !ClientId -> !Secret -> OAuthClient
[_clientId] :: OAuthClient -> !ClientId
[_clientSecret] :: OAuthClient -> !Secret

-- | An OAuth bearer type token of the following form:
--   
--   <pre>
--   {
--     \"token_type\": \"Bearer\",
--     \"access_token\": \"eyJhbGci...\",
--     \"refresh_token\": \"1/B3gq9K...\",
--     \"expires_in\": 3600,
--     ...
--   }
--   </pre>
--   
--   The <a>_tokenAccess</a> field will be inserted verbatim into the
--   <tt>Authorization: Bearer ...</tt> header for all HTTP requests.
data OAuthToken (s :: [Symbol])
OAuthToken :: !AccessToken -> !(Maybe RefreshToken) -> !UTCTime -> OAuthToken
[_tokenAccess] :: OAuthToken -> !AccessToken
[_tokenRefresh] :: OAuthToken -> !(Maybe RefreshToken)
[_tokenExpiry] :: OAuthToken -> !UTCTime

-- | An OAuth client authorization code.
newtype OAuthCode (s :: [Symbol])
OAuthCode :: Text -> OAuthCode

-- | An OAuth2 scope.
newtype OAuthScope
OAuthScope :: Text -> OAuthScope

-- | An OAuth2 access token.
newtype AccessToken
AccessToken :: Text -> AccessToken

-- | An OAuth2 refresh token.
newtype RefreshToken
RefreshToken :: Text -> RefreshToken

-- | An opaque client secret.
newtype Secret
Secret :: Text -> Secret

-- | A service identifier.
newtype ServiceId
ServiceId :: Text -> ServiceId

-- | A client identifier.
newtype ClientId
ClientId :: Text -> ClientId


-- | Environment and Google specific configuration for the
--   <a>Network.Google</a> monad.
module Network.Google.Env

-- | The environment containing the parameters required to make Google
--   requests.
data Env (s :: [Symbol])
Env :: !(Dual (Endo ServiceConfig)) -> !Logger -> !Manager -> !(Store s) -> Env
[_envOverride] :: Env -> !(Dual (Endo ServiceConfig))
[_envLogger] :: Env -> !Logger
[_envManager] :: Env -> !Manager
[_envStore] :: Env -> !(Store s)
class HasEnv s a | a -> s
environment :: HasEnv s a => Lens' a (Env s)

-- | The currently applied overrides to all <tt>Service</tt> configuration.
envOverride :: HasEnv s a => Lens' a (Dual (Endo ServiceConfig))

-- | The function used to output log messages.
envLogger :: HasEnv s a => Lens' a Logger

-- | The <a>Manager</a> used to create and manage open HTTP connections.
envManager :: HasEnv s a => Lens' a Manager

-- | The credential store used to sign requests for authentication with
--   Google.
envStore :: HasEnv s a => Lens' a (Store s)

-- | The authorised OAuth2 scopes.
--   
--   <i>See:</i> <a>allow</a>, <a>!</a>, and the related scopes available
--   for each service.
envScopes :: HasEnv s a => Lens' a (Proxy s)

-- | Provide a function which will be added to the stack of overrides,
--   which are applied to all service configurations. This provides a way
--   to configure any request that is sent using the modified <a>Env</a>.
--   
--   <i>See:</i> <a>override</a>.
configure :: HasEnv s a => (ServiceConfig -> ServiceConfig) -> a -> a

-- | Override a specific <a>ServiceConfig</a>. All requests belonging to
--   the supplied service will use this configuration instead of the
--   default.
--   
--   Typically you would override a modified version of the default
--   <a>ServiceConfig</a> for the desired service:
--   
--   <pre>
--   override (gmailService &amp; serviceHost .~ "localhost") env
--   </pre>
--   
--   Or when using <a>Network.Google</a> with <a>Control.Monad.Reader</a>
--   or <a>Control.Lens.Zoom</a> and the <a>ServiceConfig</a> lenses:
--   
--   <pre>
--   local (override (computeService &amp; serviceHost .~ "localhost")) $ do
--      ...
--   </pre>
--   
--   <i>See:</i> <a>configure</a>.
override :: HasEnv s a => ServiceConfig -> a -> a

-- | Scope an action such that any HTTP response will use this timeout
--   value.
--   
--   Default timeouts are chosen by considering:
--   
--   <ul>
--   <li>This <a>timeout</a>, if set.</li>
--   <li>The related <tt>Service</tt> timeout for the sent request if set.
--   (Default 70s)</li>
--   <li>The <a>envManager</a> timeout, if set.</li>
--   <li>The <tt>ClientRequest</tt> timeout. (Default 30s)</li>
--   </ul>
timeout :: (MonadReader r m, HasEnv s r) => Seconds -> m a -> m a

-- | Creates a new environment with a newly initialized <a>Manager</a>,
--   without logging. and Credentials that are determined by calling
--   <a>getApplicationDefault</a>. Use <a>newEnvWith</a> to supply custom
--   credentials such as an <a>OAuthClient</a> and <a>OAuthCode</a>.
--   
--   The <tt>Allow</tt>ed <a>OAuthScope</a>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate scopes.
--   See the top-level module of each individual <tt>gogol-*</tt> library
--   for a list of available scopes, such as
--   <tt>Network.Google.Compute.authComputeScope</tt>. Lenses from
--   <a>HasEnv</a> can be used to further configure the resulting
--   <a>Env</a>.
--   
--   <i>See:</i> <a>newEnvWith</a>, <a>getApplicationDefault</a>.
newEnv :: (MonadIO m, MonadCatch m, AllowScopes s) => m (Env s)

-- | Create a new environment.
--   
--   <i>See:</i> <a>newEnv</a>.
newEnvWith :: (MonadIO m, MonadCatch m, AllowScopes s) => Credentials s -> Logger -> Manager -> m (Env s)
instance Network.Google.Env.HasEnv s (Network.Google.Env.Env s)


-- | This module provides a <a>Google</a> monad and common set of
--   operations which can be performed against the remote Google Service
--   APIs. Typically you will import this module along with modules from
--   various <tt>gogol-*</tt> libraries for the services you wish to
--   communicate with.
module Network.Google

-- | The <a>Google</a> monad containing configuration environment and
--   tracks resource allocation via <a>ResourceT</a>. The functions in
--   <a>Network.Google</a> are generalised
newtype Google s a
Google :: ReaderT (Env s) (ResourceT IO) a -> Google s a
[unGoogle] :: Google s a -> ReaderT (Env s) (ResourceT IO) a

-- | Monads in which <a>Google</a> actions may be embedded.
--   
--   The functions in <a>Network.Google</a> have <a>MonadGoogle</a>
--   constraints to provide automatic lifting when embedding <a>Google</a>
--   as a layer inside your own application stack.
class (Functor m, Applicative m, Monad m, MonadIO m, MonadCatch m, AllowScopes s) => MonadGoogle s m | m -> s

-- | Lift a computation to the <a>Google</a> monad.
liftGoogle :: MonadGoogle s m => Google s a -> m a

-- | Run a <a>Google</a> action using the specified environment and
--   credentials annotated with sufficient authorization scopes.
runGoogle :: (MonadResource m, HasEnv s r) => r -> Google s a -> m a
runResourceT :: MonadUnliftIO m => ResourceT m a -> m a

-- | The environment containing the parameters required to make Google
--   requests.
data Env (s :: [Symbol])
class HasEnv s a | a -> s
environment :: HasEnv s a => Lens' a (Env s)

-- | The currently applied overrides to all <tt>Service</tt> configuration.
envOverride :: HasEnv s a => Lens' a (Dual (Endo ServiceConfig))

-- | The function used to output log messages.
envLogger :: HasEnv s a => Lens' a Logger

-- | The <a>Manager</a> used to create and manage open HTTP connections.
envManager :: HasEnv s a => Lens' a Manager

-- | The credential store used to sign requests for authentication with
--   Google.
envStore :: HasEnv s a => Lens' a (Store s)

-- | The authorised OAuth2 scopes.
--   
--   <i>See:</i> <a>allow</a>, <a>!</a>, and the related scopes available
--   for each service.
envScopes :: HasEnv s a => Lens' a (Proxy s)

-- | Creates a new environment with a newly initialized <a>Manager</a>,
--   without logging. and Credentials that are determined by calling
--   <a>getApplicationDefault</a>. Use <a>newEnvWith</a> to supply custom
--   credentials such as an <a>OAuthClient</a> and <a>OAuthCode</a>.
--   
--   The <tt>Allow</tt>ed <a>OAuthScope</a>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate scopes.
--   See the top-level module of each individual <tt>gogol-*</tt> library
--   for a list of available scopes, such as
--   <tt>Network.Google.Compute.authComputeScope</tt>. Lenses from
--   <a>HasEnv</a> can be used to further configure the resulting
--   <a>Env</a>.
--   
--   <i>See:</i> <a>newEnvWith</a>, <a>getApplicationDefault</a>.
newEnv :: (MonadIO m, MonadCatch m, AllowScopes s) => m (Env s)

-- | Create a new environment.
--   
--   <i>See:</i> <a>newEnv</a>.
newEnvWith :: (MonadIO m, MonadCatch m, AllowScopes s) => Credentials s -> Logger -> Manager -> m (Env s)

-- | Performs credentials discovery in the following order:
--   
--   <ol>
--   <li>Read the default credentials from a file specified by the
--   environment variable <tt>GOOGLE_APPLICATION_CREDENTIALS</tt> if it
--   exists.</li>
--   <li>Read the platform equivalent of
--   <tt>~/.config/gcloud/application_default_credentials.json</tt> if it
--   exists. The <tt>~/.config</tt> component of the path can be overriden
--   by the environment variable <tt>CLOUDSDK_CONFIG</tt> if it
--   exists.</li>
--   <li>Retrieve the default service account application credentials if
--   running on GCE. The environment variable <tt>NO_GCE_CHECK</tt> can be
--   used to skip this check if set to a truthy value such as <tt>1</tt> or
--   <tt>true</tt>.</li>
--   </ol>
--   
--   The specified <tt>Scope</tt>s are used to authorize any
--   <tt>service_account</tt> that is found with the appropriate OAuth2
--   scopes, otherwise they are not used. See the top-level module of each
--   individual <tt>gogol-*</tt> library for a list of available scopes,
--   such as <tt>Network.Google.Compute.computeScope</tt>.
--   
--   <i>See:</i> <a>Application Default Credentials</a>
getApplicationDefault :: (MonadIO m, MonadCatch m) => Manager -> m (Credentials s)

-- | Append two sets of scopes.
--   
--   <i>See:</i> <a>allow</a>.
(!) :: proxy xs -> proxy ys -> Proxy (Nub (xs ++ ys))

-- | Annotate credentials with the specified scopes. This exists to allow
--   users to choose between using <tt>newEnv</tt> with a <a>Proxy</a>
--   constructed by <a>!</a>, or explicitly specifying scopes via a type
--   annotation.
--   
--   <i>See:</i> <a>!</a>, <tt>envScopes</tt>, and the scopes available for
--   each service.
allow :: proxy s -> k s -> k s
class AllowScopes a

-- | Determine if _any_ of the scopes a request requires is listed in the
--   scopes the credentials supports.
--   
--   For error message/presentation purposes, this wraps the result of the
--   <a>HasScope</a> membership check to show both lists of scopes before
--   reduction.

-- | Send a request, returning the associated response if successful.
--   
--   Throws <a>Error</a>.
send :: (MonadGoogle s m, HasScope s a, GoogleRequest a) => a -> m (Rs a)

-- | Send a request returning the associated streaming media response if
--   successful.
--   
--   Some request data types have two possible responses, the JSON metadata
--   and a streaming media response. Use <a>send</a> to retrieve the
--   metadata and <a>download</a> to retrieve the streaming media.
--   
--   Equivalent to:
--   
--   <pre>
--   <a>send</a> . <a>MediaDownload</a>
--   </pre>
--   
--   Throws <a>Error</a>.
download :: (MonadGoogle s m, HasScope s (MediaDownload a), GoogleRequest (MediaDownload a)) => a -> m (Rs (MediaDownload a))

-- | Send a request with an attached <a>multipart/related media</a> upload.
--   
--   Equivalent to:
--   
--   <pre>
--   <a>send</a> . <a>MediaUpload</a>
--   </pre>
--   
--   Throws <a>Error</a>.
upload :: (MonadGoogle s m, HasScope s (MediaUpload a), GoogleRequest (MediaUpload a)) => a -> Body -> m (Rs (MediaUpload a))

-- | A single part of a (potentially multipart) request body.
--   
--   <i>Note:</i> The <a>IsString</a> instance defaults to a
--   <tt>text/plain</tt> MIME type.
data Body
Body :: !MediaType -> !RequestBody -> Body

-- | A lens into the <a>MediaType</a> of a request <a>Body</a>.
bodyContentType :: Lens' Body MediaType

-- | Construct a <a>Body</a> from a <a>FilePath</a>.
--   
--   This uses <a>getMIMEType</a> to calculate the MIME type from the file
--   extension, you can use <tt>bodyContentType</tt> to set a MIME type
--   explicitly.
sourceBody :: MonadIO m => FilePath -> m Body

-- | Attempt to calculate the MIME type based on file extension.
--   
--   Defaults to <tt>application/octet-stream</tt> if no file extension is
--   recognised.
getMIMEType :: FilePath -> MediaType

-- | Provide a function which will be added to the stack of overrides,
--   which are applied to all service configurations. This provides a way
--   to configure any request that is sent using the modified <a>Env</a>.
--   
--   <i>See:</i> <a>override</a>.
configure :: HasEnv s a => (ServiceConfig -> ServiceConfig) -> a -> a

-- | Override a specific <a>ServiceConfig</a>. All requests belonging to
--   the supplied service will use this configuration instead of the
--   default.
--   
--   Typically you would override a modified version of the default
--   <a>ServiceConfig</a> for the desired service:
--   
--   <pre>
--   override (gmailService &amp; serviceHost .~ "localhost") env
--   </pre>
--   
--   Or when using <a>Network.Google</a> with <a>Control.Monad.Reader</a>
--   or <a>Control.Lens.Zoom</a> and the <a>ServiceConfig</a> lenses:
--   
--   <pre>
--   local (override (computeService &amp; serviceHost .~ "localhost")) $ do
--      ...
--   </pre>
--   
--   <i>See:</i> <a>configure</a>.
override :: HasEnv s a => ServiceConfig -> a -> a

-- | Scope an action such that any HTTP response will use this timeout
--   value.
--   
--   Default timeouts are chosen by considering:
--   
--   <ul>
--   <li>This <a>timeout</a>, if set.</li>
--   <li>The related <tt>Service</tt> timeout for the sent request if set.
--   (Default 70s)</li>
--   <li>The <a>envManager</a> timeout, if set.</li>
--   <li>The <tt>ClientRequest</tt> timeout. (Default 30s)</li>
--   </ul>
timeout :: (MonadReader r m, HasEnv s r) => Seconds -> m a -> m a

-- | The remote host name, used for both the IP address to connect to and
--   the host request header.
serviceHost :: Lens' ServiceConfig ByteString

-- | The remote port to connect to.
--   
--   Defaults to <tt>443</tt>.
servicePort :: Lens' ServiceConfig Int

-- | A path prefix that is prepended to any sent HTTP request.
--   
--   Defaults to <tt>mempty</tt>.
servicePath :: Lens' ServiceConfig Builder

-- | Whether to use HTTPS/SSL.
--   
--   Defaults to <tt>True</tt>.
serviceSecure :: Lens' ServiceConfig Bool

-- | Number of seconds to wait for a response.
serviceTimeout :: Lens' ServiceConfig Maybe Seconds
class AsError a

-- | A general Amazonka error.
_Error :: AsError a => Prism' a Error

-- | An error occured while communicating over HTTP with a remote service.
_TransportError :: AsError a => Prism' a HttpException

-- | A serialisation error occured when attempting to deserialise a
--   response.
_SerializeError :: AsError a => Prism' a SerializeError

-- | A service specific error returned by the remote service.
_ServiceError :: AsError a => Prism' a ServiceError
class AsAuthError a

-- | A general authentication error.
_AuthError :: AsAuthError a => Prism' a AuthError

-- | An error occured while communicating over HTTP with either then local
--   metadata or remote accounts.google.com endpoints.
_RetrievalError :: AsAuthError a => Prism' a HttpException

-- | The specified default credentials file could not be found.
_MissingFileError :: AsAuthError a => Prism' a FilePath

-- | An error occured parsing the default credentials file.
_InvalidFileError :: AsAuthError a => Prism' a (FilePath, Text)

-- | An error occured when attempting to refresh a token.
_TokenRefreshError :: AsAuthError a => Prism' a (Status, Text, Maybe Text)
trying :: MonadCatch m => Getting First a SomeException a -> m r -> m Either a r
catching :: MonadCatch m => Getting First a SomeException a -> m r -> a -> m r -> m r

-- | A function threaded through various request and serialisation routines
--   to log informational and debug messages.
type Logger = LogLevel -> Builder -> IO ()
data LogLevel

-- | Info messages supplied by the user - this level is not emitted by the
--   library.
Info :: LogLevel

-- | Error messages only.
Error :: LogLevel

-- | Useful debug information + info + error levels.
Debug :: LogLevel

-- | Includes potentially credentials metadata, and non-streaming response
--   bodies.
Trace :: LogLevel

-- | This is a primitive logger which can be used to log builds to a
--   <a>Handle</a>.
--   
--   <i>Note:</i> A more sophisticated logging library such as
--   <a>tinylog</a> or <a>fast-logger</a> should be used in production
--   code.
newLogger :: MonadIO m => LogLevel -> Handle -> m Logger
newManager :: ManagerSettings -> IO Manager
tlsManagerSettings :: ManagerSettings
instance Control.Monad.Trans.Resource.Internal.MonadResource (Network.Google.Google s)
instance Control.Monad.Reader.Class.MonadReader (Network.Google.Env.Env s) (Network.Google.Google s)
instance Control.Monad.Catch.MonadMask (Network.Google.Google s)
instance Control.Monad.Catch.MonadCatch (Network.Google.Google s)
instance Control.Monad.Catch.MonadThrow (Network.Google.Google s)
instance Control.Monad.IO.Class.MonadIO (Network.Google.Google s)
instance GHC.Base.MonadPlus (Network.Google.Google s)
instance GHC.Base.Monad (Network.Google.Google s)
instance GHC.Base.Alternative (Network.Google.Google s)
instance GHC.Base.Applicative (Network.Google.Google s)
instance GHC.Base.Functor (Network.Google.Google s)
instance Network.Google.Auth.Scope.AllowScopes s => Network.Google.MonadGoogle s (Network.Google.Google s)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.Identity.IdentityT m)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.List.ListT m)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.Maybe.MaybeT m)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.Except.ExceptT e m)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.Reader.ReaderT r m)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.State.Strict.StateT s' m)
instance Network.Google.MonadGoogle s m => Network.Google.MonadGoogle s (Control.Monad.Trans.State.Lazy.StateT s' m)
instance (GHC.Base.Monoid w, Network.Google.MonadGoogle s m) => Network.Google.MonadGoogle s (Control.Monad.Trans.Writer.Strict.WriterT w m)
instance (GHC.Base.Monoid w, Network.Google.MonadGoogle s m) => Network.Google.MonadGoogle s (Control.Monad.Trans.Writer.Lazy.WriterT w m)
instance (GHC.Base.Monoid w, Network.Google.MonadGoogle s m) => Network.Google.MonadGoogle s (Control.Monad.Trans.RWS.Strict.RWST r w s' m)
instance (GHC.Base.Monoid w, Network.Google.MonadGoogle s m) => Network.Google.MonadGoogle s (Control.Monad.Trans.RWS.Lazy.RWST r w s' m)
instance Control.Monad.IO.Unlift.MonadUnliftIO (Network.Google.Google s)
